<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InternalUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pcond</a> &gt; <a href="index.source.html" class="el_package">com.github.dakusui.pcond.internals</a> &gt; <span class="el_source">InternalUtils.java</span></div><h1>InternalUtils.java</h1><pre class="source lang-java linenums">package com.github.dakusui.pcond.internals;

import com.github.dakusui.pcond.core.Evaluable;
import com.github.dakusui.pcond.core.printable.PrintableFunction;
import com.github.dakusui.pcond.core.printable.PrintablePredicate;
import com.github.dakusui.pcond.forms.Functions;
import com.github.dakusui.pcond.forms.Printables;
import com.github.dakusui.pcond.validator.Explanation;
import com.github.dakusui.pcond.validator.Validator;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;

import static java.lang.String.format;
import static java.util.Arrays.asList;
import static java.util.Collections.unmodifiableList;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;

<span class="pc bpc" id="L23" title="1 of 2 branches missed.">public enum InternalUtils {</span>
  ;

<span class="fc" id="L26">  private static final Predicate&lt;?&gt;   DUMMY_PREDICATE = Printables.predicate(&quot;DUMMY_PREDICATE:ALWAYSTHROW&quot;, v -&gt; {</span>
<span class="fc" id="L27">    throw new UnsupportedOperationException(&quot;Testing: '&quot; + v + &quot;' was failed, because this is a dummy predicate.&quot;);</span>
  });
<span class="fc" id="L29">  private static final Function&lt;?, ?&gt; DUMMY_FUNCTION  = Printables.function(&quot;DUMMY_FUNCTION:ALWAYSTHROW&quot;, v -&gt; {</span>
<span class="fc" id="L30">    throw new UnsupportedOperationException(&quot;Applying: '&quot; + v + &quot;' was failed, because this is a dummy predicate.&quot;);</span>
  });

  public static String formatObject(Object value) {
<span class="fc" id="L34">    return formatObject(value, summarizedStringLength());</span>
  }

  public static String formatObject(Object value, int maxLength) {
<span class="fc" id="L38">    return _formatObject(value, maxLength).replaceAll(&quot;[\\r\\n]&quot;, &quot; &quot;);</span>
  }

  private static String _formatObject(Object value, int maxLength) {
<span class="fc bfc" id="L42" title="All 2 branches covered.">    if (value == null)</span>
<span class="fc" id="L43">      return &quot;null&quot;;</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">    if (value instanceof Collection) {</span>
<span class="fc" id="L45">      Collection&lt;?&gt; collection = (Collection&lt;?&gt;) value;</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">      if (collection.size() &lt; 4)</span>
<span class="fc" id="L47">        return format(&quot;[%s]&quot;,</span>
<span class="fc" id="L48">            collection.stream()</span>
<span class="fc" id="L49">                .map(InternalUtils::formatObject)</span>
<span class="fc" id="L50">                .collect(joining(&quot;,&quot;)));</span>
<span class="fc" id="L51">      Iterator&lt;?&gt; i = collection.iterator();</span>
<span class="fc" id="L52">      return format(&quot;[%s,%s,%s...;%s]&quot;,</span>
<span class="fc" id="L53">          formatObject(i.next()),</span>
<span class="fc" id="L54">          formatObject(i.next()),</span>
<span class="fc" id="L55">          formatObject(i.next()),</span>
<span class="fc" id="L56">          collection.size()</span>
      );
    }
<span class="fc bfc" id="L59" title="All 2 branches covered.">    if (value instanceof Object[])</span>
<span class="fc" id="L60">      return formatObject(asList((Object[]) value));</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">    if (value instanceof Formattable)</span>
<span class="fc" id="L62">      return String.format(&quot;%s&quot;, value);</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">    if (value instanceof String) {</span>
<span class="fc" id="L64">      String s = (String) value;</span>
<span class="fc" id="L65">      s = summarizeString(s, maxLength);</span>
<span class="fc" id="L66">      return format(&quot;\&quot;%s\&quot;&quot;, s);</span>
    }
<span class="fc bfc" id="L68" title="All 2 branches covered.">    if (value instanceof Throwable) {</span>
<span class="fc" id="L69">      Throwable throwable = (Throwable) value;</span>
<span class="fc" id="L70">      String simpleName = summarizeString(throwable.getClass().getSimpleName() + &quot;:&quot;, maxLength);</span>
<span class="fc" id="L71">      return simpleName +</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">          (simpleName.length() &lt; Math.max(12, maxLength) ?</span>
<span class="fc" id="L73">              formatObject(throwable.getMessage(), toNextEven(Math.max(12, maxLength - simpleName.length()))) :</span>
              &quot;&quot;);
    }
<span class="fc bfc" id="L76" title="All 2 branches covered.">    if (isToStringOverridden(value))</span>
<span class="fc" id="L77">      return summarizeString(</span>
<span class="fc" id="L78">          value.toString(),</span>
          maxLength + 2 /* 2 for margin for single quotes not necessary for non-strings */
      );
<span class="fc" id="L81">    return value.toString().substring(value.getClass().getPackage().getName().length() + 1);</span>
  }

  public static String explainValue(Object value) {
<span class="fc" id="L85">    StringBuilder b = new StringBuilder();</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">    if (value instanceof Collection) {</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">      for (Object each : (Collection&lt;?&gt;) value) {</span>
<span class="fc" id="L88">        explainValue(b, 0, each);</span>
<span class="fc" id="L89">      }</span>
    } else {
<span class="fc" id="L91">      explainValue(b, 0, value);</span>
    }
<span class="fc" id="L93">    return b.toString().trim();</span>
  }

  private static void explainValue(StringBuilder buffer, int level, Object value) {
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">    if (value instanceof Collection) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">      if (((Collection&lt;?&gt;) value).isEmpty())</span>
<span class="nc" id="L99">        explainValue(buffer, level, &quot;[]&quot;);</span>
      else {
<span class="nc bnc" id="L101" title="All 2 branches missed.">        for (Object each : (Collection&lt;?&gt;) value)</span>
<span class="nc" id="L102">          explainValue(buffer, level + 1, each);</span>
      }
    } else {
<span class="fc" id="L105">      buffer.append(String.format(&quot;%s%s%n&quot;, spaces(level * 2), value));</span>
    }
<span class="fc" id="L107">  }</span>

  private static String spaces(int spaces) {
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">    if (spaces &lt;= 0)</span>
<span class="fc" id="L111">      return &quot;&quot;;</span>
<span class="nc" id="L112">    return String.format(&quot;%-&quot; + (spaces) + &quot;s&quot;, &quot;&quot;);</span>
  }

  private static int toNextEven(int value) {
<span class="fc bfc" id="L116" title="All 2 branches covered.">    if ((value &amp; 1) == 0)</span>
<span class="fc" id="L117">      return value;</span>
<span class="fc" id="L118">    return value + 1;</span>
  }

  private static String summarizeString(String s, int length) {
<span class="pc bpc" id="L122" title="2 of 4 branches missed.">    assert (length &amp; 1) == 0 : &quot;The length must be an even int, but was &lt;&quot; + length + &quot;&gt;&quot;;</span>
<span class="pc bpc" id="L123" title="2 of 4 branches missed.">    assert length &gt;= 12 : &quot;The length must be greater than or equal to 12. Less than 20 is not recommended. But was &lt;&quot; + length + &quot;&gt;&quot;;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">    if (s.length() &gt; length) {</span>
<span class="fc" id="L125">      int pre = length / 2 - 2;</span>
<span class="fc" id="L126">      int post = length / 2 - 5;</span>
<span class="fc" id="L127">      s = s.substring(0, length - pre) + &quot;...&quot; + s.substring(s.length() - post);</span>
    }
<span class="fc" id="L129">    return s;</span>
  }

  public static int summarizedStringLength() {
<span class="fc" id="L133">    return Validator.instance().configuration().summarizedStringLength();</span>
  }

  private static boolean isToStringOverridden(Object object) {
<span class="fc bfc" id="L137" title="All 2 branches covered.">    return getMethod(object.getClass(), &quot;toString&quot;).getDeclaringClass() != Object.class;</span>
  }

  /**
   * A method to check if assertion is enabled or not.
   *
   * @param v A boolean value to test.
   * @return {@code true} - assertion failed with the given value {@code v} / {@code false} - otherwise.
   */
  public static boolean assertFailsWith(boolean v) {
<span class="fc" id="L147">    boolean ret = false;</span>
    try {
<span class="pc bpc" id="L149" title="1 of 4 branches missed.">      assert v;</span>
<span class="fc" id="L150">    } catch (AssertionError e) {</span>
<span class="fc" id="L151">      ret = true;</span>
<span class="fc" id="L152">    }</span>
<span class="fc" id="L153">    return ret;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; T createInstanceFromClassName(Class&lt;? super T&gt; expectedClass, String requestedClassName, Object... args) {
    try {
<span class="fc" id="L159">      Class&lt;?&gt; loadedClass = Class.forName(requestedClassName);</span>
      try {
<span class="fc" id="L161">        return (T) expectedClass.cast(loadedClass.getDeclaredConstructor(Arrays.stream(args).map(Object::getClass).toArray(Class&lt;?&gt;[]::new)).newInstance(args));</span>
<span class="fc" id="L162">      } catch (ClassCastException e) {</span>
<span class="pc" id="L163">        throw executionFailure(&quot;The requested class:'&quot; + requestedClassName +</span>
<span class="fc" id="L164">                &quot;' was found but not an instance of &quot; + expectedClass.getCanonicalName() + &quot;.: &quot; +</span>
<span class="fc" id="L165">                &quot;It was '&quot; + loadedClass.getCanonicalName() + &quot;'.&quot;,</span>
            e);
<span class="fc" id="L167">      } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L168">        throw executionFailure(&quot;Matching public constructor for &quot; + Arrays.toString(args) + &quot; was not found in &quot; + requestedClassName, e);</span>
<span class="fc" id="L169">      } catch (InvocationTargetException e) {</span>
<span class="nc" id="L170">        throw executionFailure(&quot;Matching public constructor was found in &quot; + requestedClassName + &quot; but threw an exception&quot;, e.getCause());</span>
      }
<span class="fc" id="L172">    } catch (InstantiationException | IllegalAccessException |</span>
        ClassNotFoundException e) {
<span class="nc" id="L174">      throw executionFailure(&quot;The requested class was not found or not accessible.: &quot; + requestedClassName, e);</span>
    }
  }

  public static InternalException executionFailure(String message, Throwable cause) {
<span class="nc" id="L179">    throw executionFailure(Explanation.fromMessage(message), cause);</span>
  }

  public static InternalException executionFailure(Explanation explanation, Throwable cause) {
<span class="fc" id="L183">    throw new InternalException(explanation.toString(), cause);</span>
  }

  public static InternalException wrapIfNecessary(Throwable cause) {
<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (cause instanceof Error)</span>
<span class="fc" id="L188">      throw (Error) cause;</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">    if (cause instanceof RuntimeException)</span>
<span class="fc" id="L190">      throw (RuntimeException) cause;</span>
<span class="nc" id="L191">    throw executionFailure(cause.getMessage(), cause);</span>
  }

  public static List&lt;? super Object&gt; append(List&lt;? super Object&gt; list, Object p) {
<span class="fc" id="L195">    return unmodifiableList(new ArrayList&lt;Object&gt;(list) {{</span>
<span class="fc" id="L196">      add(p);</span>
<span class="fc" id="L197">    }});</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; Evaluable&lt;T&gt; toEvaluableIfNecessary(Predicate&lt;? super T&gt; p) {
<span class="fc" id="L202">    requireNonNull(p);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">    if (p instanceof Evaluable)</span>
<span class="fc" id="L204">      return (Evaluable&lt;T&gt;) p;</span>
    // We know that Printable.predicate returns a PrintablePredicate object, which is an Evaluable.
<span class="fc" id="L206">    return (Evaluable&lt;T&gt;) Printables.predicate(p::toString, p);</span>
  }

  public static &lt;T&gt; Evaluable&lt;T&gt; toEvaluableIfNecessary(Function&lt;? super T, ?&gt; f) {
<span class="fc" id="L210">    return toEvaluableWithFormatterIfNecessary(f, Object::toString);</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; Evaluable&lt;T&gt; toEvaluableWithFormatterIfNecessary(Function&lt;? super T, ?&gt; f, Function&lt;Function&lt;? super T, ?&gt;, String&gt; formatter) {
<span class="fc" id="L215">    requireNonNull(f);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">    if (f instanceof Evaluable)</span>
<span class="fc" id="L217">      return (Evaluable&lt;T&gt;) f;</span>
    // We know that Printable.predicate returns a PrintableFunction object, which is an Evaluable.
<span class="fc" id="L219">    return (Evaluable&lt;T&gt;) Printables.function(() -&gt; formatter.apply(f), f);</span>
  }

  public static Class&lt;?&gt; wrapperClassOf(Class&lt;?&gt; clazz) {
<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (clazz == Integer.TYPE)</span>
<span class="fc" id="L224">      return Integer.class;</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">    if (clazz == Long.TYPE)</span>
<span class="fc" id="L226">      return Long.class;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">    if (clazz == Boolean.TYPE)</span>
<span class="fc" id="L228">      return Boolean.class;</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (clazz == Byte.TYPE)</span>
<span class="fc" id="L230">      return Byte.class;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">    if (clazz == Character.TYPE)</span>
<span class="fc" id="L232">      return Character.class;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">    if (clazz == Float.TYPE)</span>
<span class="fc" id="L234">      return Float.class;</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">    if (clazz == Double.TYPE)</span>
<span class="fc" id="L236">      return Double.class;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">    if (clazz == Short.TYPE)</span>
<span class="fc" id="L238">      return Short.class;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">    if (clazz == Void.TYPE)</span>
<span class="fc" id="L240">      return Void.class;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">    throw new IllegalArgumentException(&quot;Unsupported type:&quot; + (clazz != null ? clazz.getName() : &quot;null&quot;) + &quot; was given.&quot;);</span>
  }

  public static Method getMethod(Class&lt;?&gt; aClass, String methodName, Class&lt;?&gt;... parameterTypes) {
    try {
<span class="fc" id="L246">      return aClass.getMethod(methodName, parameterTypes);</span>
<span class="fc" id="L247">    } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L248">      throw executionFailure(format(&quot;Requested method: %s(%s) was not found in %s&quot;, methodName, Arrays.stream(parameterTypes).map(Class::getName).collect(joining(&quot;,&quot;)), aClass.getName()), e);</span>
    }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; Predicate&lt;? super T&gt; dummyPredicate() {
<span class="fc" id="L254">    return (Predicate&lt;? super T&gt;) DUMMY_PREDICATE;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T, R&gt; Function&lt;T, R&gt; dummyFunction() {
<span class="fc" id="L259">    return (Function&lt;T, R&gt;) DUMMY_FUNCTION;</span>
  }

  public static boolean isDummyFunction(Function&lt;?, ?&gt; function) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">    return function == DUMMY_FUNCTION;</span>
  }

  public static Object toNonStringObject(String s) {
<span class="fc" id="L267">    return new Object() {</span>
      @Override
      public String toString() {
<span class="fc" id="L270">        return s;</span>
      }
    };
  }

  public static String indent(int level) {
<span class="fc bfc" id="L276" title="All 2 branches covered.">    return level == 0 ?</span>
        &quot;&quot; :
<span class="fc" id="L278">        format(&quot;%&quot; + (level * 2) + &quot;s&quot;, &quot;&quot;);</span>
  }

  public static String newLine() {
<span class="fc" id="L282">    return format(&quot;%n&quot;);</span>
  }

  /**
   * Marks &quot;trivial&quot; a given function.
   * A predicate marked trivial will not appear in an execution report.
   *
   * @param predicate A predicate to be marked.
   * @param &lt;T&gt;      Input type of the function.
   * @return A predicate marked trivial.
   */
  public static &lt;T&gt; Predicate&lt;T&gt; makeSquashable(Predicate&lt;T&gt; predicate) {
<span class="fc" id="L294">    return ((PrintablePredicate&lt;T&gt;) predicate).makeTrivial();</span>
  }

  /**
   * Marks &quot;trivial&quot; given function.
   * A function marked trivial will not appear in an execution report.
   *
   * @param function A function to marked.
   * @param &lt;T&gt;      Input type of the function.
   * @param &lt;R&gt;      Output type of the function.
   * @return A function marked trivial.
   */
  public static &lt;T, R&gt; Function&lt;T, R&gt; makeSquashable(Function&lt;T, R&gt; function) {
<span class="nc" id="L307">    return ((PrintableFunction&lt;T, R&gt;) function).makeTrivial();</span>
  }

  public static &lt;T&gt; Function&lt;T, T&gt; trivialIdentityFunction() {
<span class="fc" id="L311">    return Functions.identity();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>